module Arena
  ( Model
  , init
  , update
  , view
  , playNextFrame
  ) where

-- <MegaAirMan> Modules
import AirMan
import Shared exposing (Frame)

-- Elm Modules
import Effects exposing (Effects)
import Html exposing (Html, div)
import Html.Attributes exposing (classList, title)
import Signal exposing (Signal)
import Time

{-| This module displays and animates the Air Man arena background.

# Model
@docs Model, Frame, init

# Update
@docs Action, update

# View
@docs view

# Signals
@docs playNextFrame
-}


-----------
-- MODEL --
-----------

{-| This model holds all animation state associated with the background sprite.
-}
type alias Model =
  { ani : AnimationState
  , airman : AirMan.Model
  }


{-| This model holds all animation state associated with the background sprite.
-}
type alias AnimationState =
  { currentFrameNumber : Int
  , currentFrame : Frame
  , f1 : Frame
  , f2 : Frame
  , f3 : Frame
  , f4 : Frame
  }


{-| Set model defaults to include all animation frames in play order, and
create an Effects queue for all the effects generated by all the sprites
this module will manage.
-}
init : (Model, Effects Action)
init =
  let
    (airmanModel, airmanFx) = AirMan.init
  in
    ( { ani =
        { currentFrameNumber = 1
        , currentFrame = "icon-mm2-airman-arena1"
        , f1 = "icon-mm2-airman-arena1"
        , f2 = "icon-mm2-airman-arena2"
        , f3 = "icon-mm2-airman-arena3"
        , f4 = "icon-mm2-airman-arena2"
        }
      , airman = airmanModel
      }
    , Effects.batch
        [ Effects.map SpriteAirMan airmanFx
        ]
    )


------------
-- UPDATE --
------------

{-| Trigger the next animation frame in the cycle with this Action and
orchestrate the main sprites. <SpriteAirMan> receives actions of some kind,
but those actions are unimportant. They are used to update the <AirMan> model
and send the new model back to the <AirMan> module. In other words, this is
a way to wire together the modules.
-}
type Action
  = NextFrame
  | SpriteAirMan AirMan.Action


{-| Updates state to cycle to the next animation frame.
-}
updateAnimationState : AnimationState -> AnimationState
updateAnimationState ani =
  let
    nextNumber = 1 + (ani.currentFrameNumber % 4)
    nextFrame =
      case nextNumber of
        4 ->
          ani.f4

        3 ->
          ani.f3

        2 ->
          ani.f2

        _ ->
          ani.f1

  in
    { ani | currentFrameNumber = nextNumber
          , currentFrame = nextFrame
    }


{-| Plays the background animation by changing the CSS classes that correspond
to animation frames in the sprite sheet.
-}
update : Action -> Model -> (Model, Effects Action)
update action model =
  case action of
    NextFrame ->
      Shared.noFx
      <| { model | ani = updateAnimationState model.ani }

    SpriteAirMan act ->
      {- Wire together the <AirMan> and <Arena> modules. The specific update
         actions are unimportant to the <Arena> module since <AirMan> has the
         responsibility to update the data.
      -}
      let
        (airman, airmanFx) = AirMan.update act model.airman
      in
        ( Model model.ani airman
        , Effects.map SpriteAirMan airmanFx
        )


----------
-- VIEW --
----------

{-| Display the sprite background as a <div> background image.
Note: <Signal.Address> input comes from the <StartApp Config.view> data type.
-}
view : Signal.Address Action -> Model -> Html
view address model =
  div -- Parent container.
    [ classList
        [ ("icon", True)
        , (model.ani.currentFrame, True)
        , ("rel", True)
        ]
    , title "Mega Air Man Arena"
    ]
    [ div -- Active area container.
      [ classList
        [ ("abs", True)
        , ("active-area", True)
        , ("active-pos", True)
        ]
      ]
      -- Send updates to <AirMan> and receive responses here at <SpriteAirMan>.
      [ AirMan.view (Signal.forwardTo address SpriteAirMan) model.airman
      ]
    ]


-------------
-- SIGNALS --
-------------

{-| Trigger the animation cycle. Prefer <Signal> to <Effects.tick> for this
animation because the program simulates choppy NES animation rather than
the duration-based approached possible with <Effects.tick>.
-}
playNextFrame : Signal Action
playNextFrame =
  Signal.map (\_ -> NextFrame) (Time.fps 3.5)
